// Code generated by protoc-gen-rangerrpc version DO NOT EDIT.
// source: integrations.proto

package integrations

import (
	"context"
	"errors"
	"net/http"
	"net/url"
	"strings"

	ranger "go.mondoo.com/ranger-rpc"
	"go.mondoo.com/ranger-rpc/metadata"
	jsonpb "google.golang.org/protobuf/encoding/protojson"
	pb "google.golang.org/protobuf/proto"
)

// service interface definition

type IntegrationsManager interface {
	List(context.Context, *Query) (*Integrations, error)
	Get(context.Context, *GetIntegrationRequest) (*Integration, error)
	GetName(context.Context, *GetNameRequest) (*GetNameResponse, error)
	GetTokenForIntegration(context.Context, *GetTokenForIntegrationRequest) (*GetTokenForIntegrationResponse, error)
	Create(context.Context, *CreateIntegrationRequest) (*CreateIntegrationResponse, error)
	Update(context.Context, *UpdateIntegrationRequest) (*UpdateIntegrationResponse, error)
	Delete(context.Context, *DeleteIntegrationRequest) (*DeleteIntegrationResponse, error)
}

// client implementation

type IntegrationsManagerClient struct {
	ranger.Client
	httpclient ranger.HTTPClient
	prefix     string
}

func NewIntegrationsManagerClient(addr string, client ranger.HTTPClient, plugins ...ranger.ClientPlugin) (*IntegrationsManagerClient, error) {
	base, err := url.Parse(ranger.SanitizeUrl(addr))
	if err != nil {
		return nil, err
	}

	u, err := url.Parse("./IntegrationsManager")
	if err != nil {
		return nil, err
	}

	serviceClient := &IntegrationsManagerClient{
		httpclient: client,
		prefix:     base.ResolveReference(u).String(),
	}
	serviceClient.AddPlugins(plugins...)
	return serviceClient, nil
}
func (c *IntegrationsManagerClient) List(ctx context.Context, in *Query) (*Integrations, error) {
	out := new(Integrations)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/List"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) Get(ctx context.Context, in *GetIntegrationRequest) (*Integration, error) {
	out := new(Integration)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Get"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) GetName(ctx context.Context, in *GetNameRequest) (*GetNameResponse, error) {
	out := new(GetNameResponse)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetName"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) GetTokenForIntegration(ctx context.Context, in *GetTokenForIntegrationRequest) (*GetTokenForIntegrationResponse, error) {
	out := new(GetTokenForIntegrationResponse)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/GetTokenForIntegration"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) Create(ctx context.Context, in *CreateIntegrationRequest) (*CreateIntegrationResponse, error) {
	out := new(CreateIntegrationResponse)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Create"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) Update(ctx context.Context, in *UpdateIntegrationRequest) (*UpdateIntegrationResponse, error) {
	out := new(UpdateIntegrationResponse)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Update"}, ""), in, out)
	return out, err
}
func (c *IntegrationsManagerClient) Delete(ctx context.Context, in *DeleteIntegrationRequest) (*DeleteIntegrationResponse, error) {
	out := new(DeleteIntegrationResponse)
	err := c.DoClientRequest(ctx, c.httpclient, strings.Join([]string{c.prefix, "/Delete"}, ""), in, out)
	return out, err
}

// server implementation

type IntegrationsManagerServerOption func(s *IntegrationsManagerServer)

func WithUnknownFieldsForIntegrationsManagerServer() IntegrationsManagerServerOption {
	return func(s *IntegrationsManagerServer) {
		s.allowUnknownFields = true
	}
}

func NewIntegrationsManagerServer(handler IntegrationsManager, opts ...IntegrationsManagerServerOption) http.Handler {
	srv := &IntegrationsManagerServer{
		handler: handler,
	}

	for i := range opts {
		opts[i](srv)
	}

	service := ranger.Service{
		Name: "IntegrationsManager",
		Methods: map[string]ranger.Method{
			"List":                   srv.List,
			"Get":                    srv.Get,
			"GetName":                srv.GetName,
			"GetTokenForIntegration": srv.GetTokenForIntegration,
			"Create":                 srv.Create,
			"Update":                 srv.Update,
			"Delete":                 srv.Delete,
		},
	}
	return ranger.NewRPCServer(&service)
}

type IntegrationsManagerServer struct {
	handler            IntegrationsManager
	allowUnknownFields bool
}

func (p *IntegrationsManagerServer) List(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req Query
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.List(ctx, &req)
}
func (p *IntegrationsManagerServer) Get(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req GetIntegrationRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Get(ctx, &req)
}
func (p *IntegrationsManagerServer) GetName(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req GetNameRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetName(ctx, &req)
}
func (p *IntegrationsManagerServer) GetTokenForIntegration(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req GetTokenForIntegrationRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.GetTokenForIntegration(ctx, &req)
}
func (p *IntegrationsManagerServer) Create(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req CreateIntegrationRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Create(ctx, &req)
}
func (p *IntegrationsManagerServer) Update(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req UpdateIntegrationRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Update(ctx, &req)
}
func (p *IntegrationsManagerServer) Delete(ctx context.Context, reqBytes *[]byte) (pb.Message, error) {
	var req DeleteIntegrationRequest
	var err error

	md, ok := metadata.FromIncomingContext(ctx)
	if !ok {
		return nil, errors.New("could not access header")
	}

	switch md.First("Content-Type") {
	case "application/protobuf", "application/octet-stream", "application/grpc+proto":
		err = pb.Unmarshal(*reqBytes, &req)
	default:
		// handle case of empty object
		if len(*reqBytes) > 0 {
			err = jsonpb.UnmarshalOptions{DiscardUnknown: true}.Unmarshal(*reqBytes, &req)
		}
	}

	if err != nil {
		return nil, err
	}
	return p.handler.Delete(ctx, &req)
}
